# Objective-C 设计模式
![Mou icon](http://a1.jikexueyuan.com/home/201601/29/7c2e/56ab1968879d8.jpg)
### 对象创建
* [原型模式]()
* [工厂方法](https://github.com/birneysky/DesignPatters/blob/master/README.md#工厂模式)
* [抽象工厂]()
* [生成器]()	
* [单例]()

### 接口适配
* [适配器]()
* [桥接]()
* [外观]()

### 对象去耦
* [中介者]()
* [观察者]()

### 抽象集合
* [组合]()
* [迭代器]()

### 行为扩展
* [访问者]()
* [装饰]()
* [责任链]()

### 算法分装
* [模板方法]()
* [策略]()
* [命令]()


---

#### 工厂模式

各种具体工厂重载其抽象父类中定义的工厂方法，并且这个重载的工厂方法创建自己的产品
 ![](Factory.png)
 抽象产品类(Product)定义了工厂方法创建对象的接口。具体产品类(ConcreteProduct)实现了抽象产品类的接口。Creator定义了返回Product对象的工厂方法。Creator的其他操作可以调用此工厂方法创建Product对象。concreteCreator是Creator的子类。它重载了工厂方法，已返回concreteProduct实例。

#### 抽象工厂
在软件设计中，如果客户端想要手工创建一个类的实例，那么客户端首先需要知道这个类的细节。更槽糕的是，一组相关的对象可以在运行时按照不同的标准创建的不一样。此时客户端需要知道全部细节才能创建他们。可以通过抽象工厂来解决这个问题。
抽象工厂提供一个固定的接口。用于创建一些列有关联或者相依存的对象。而不必指定其具体类或者其他创建细节。客户端与从工厂得到的具体对象之间没有耦合。
![](AbstractFactory.png)
如上图所示，Client只知道AbstractFactory和AbstractProduct。每个工厂类中，结构与实际操作的细节按黑箱对待。甚至产品也不知道谁将创建它们。只有具体的工厂知道为客户端创建什么，如何创建。工厂方法把实际创建工作推到重载它的子类去完成。在类图中，createProductA 和 createProductB是工程方法。最初的抽象方法什么也不创建。这种抽象十分通用广泛用于任何需要抽象创建过程的场合。

* 软件设计黄金法则：变动需要抽象。

如果有多个类共有相同的行为，但实际实现却不同，即可能需要某种抽象类型作为其父类被继承。抽象类型定义所有相关具体类共有的共同行为。


