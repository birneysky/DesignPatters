# Objective-C 设计模式
![Mou icon](http://a1.jikexueyuan.com/home/201601/29/7c2e/56ab1968879d8.jpg)
### 对象创建
* [原型模式]()
* [工厂方法](https://github.com/birneysky/DesignPatters/blob/master/README.md#工厂模式)
* [抽象工厂]()
* [生成器]()	
* [单例]()

### 接口适配
* [适配器]()
* [桥接]()
* [外观]()

### 对象去耦
* [中介者]()
* [观察者]()

### 抽象集合
* [组合]()
* [迭代器]()

### 行为扩展
* [访问者]()
* [装饰]()
* [责任链]()

### 算法分装
* [模板方法]()
* [策略]()
* [命令]()


---

#### 工厂模式

各种具体工厂重载其抽象父类中定义的工厂方法，并且这个重载的工厂方法创建自己的产品
 ![](Factory.png)
 抽象产品类(Product)定义了工厂方法创建对象的接口。具体产品类(ConcreteProduct)实现了抽象产品类的接口。Creator定义了返回Product对象的工厂方法。Creator的其他操作可以调用此工厂方法创建Product对象。concreteCreator是Creator的子类。它重载了工厂方法，已返回concreteProduct实例。

---

#### 抽象工厂
在软件设计中，如果客户端想要手工创建一个类的实例，那么客户端首先需要知道这个类的细节。更槽糕的是，一组相关的对象可以在运行时按照不同的标准创建的不一样。此时客户端需要知道全部细节才能创建他们。可以通过抽象工厂来解决这个问题。
抽象工厂提供一个固定的接口。用于创建一些列有关联或者相依存的对象。而不必指定其具体类或者其他创建细节。客户端与从工厂得到的具体对象之间没有耦合。
![](AbstractFactory.png)
如上图所示，Client只知道AbstractFactory和AbstractProduct。每个工厂类中，结构与实际操作的细节按黑箱对待。甚至产品也不知道谁将创建它们。只有具体的工厂知道为客户端创建什么，如何创建。工厂方法把实际创建工作推到重载它的子类去完成。在类图中，createProductA 和 createProductB是工程方法。最初的抽象方法什么也不创建。这种抽象十分通用广泛用于任何需要抽象创建过程的场合。

* 软件设计黄金法则：变动需要抽象。

如果有多个类共有相同的行为，但实际实现却不同，即可能需要某种抽象类型作为其父类被继承。抽象类型定义所有相关具体类共有的共同行为。

---

#### 生成器
选择构建自己房子的人会把工程外包给承包商。单一承包商不能建造整个房子，他将其分解为几个部分，然后转包给几个实际的建筑商(builder),他们懂得如何将零部件组装起来。房子由风格、颜色和尺寸各不相同的部件组成。客户告诉承包商房子里都有什么，然后承包商协调各房屋建筑商，决定需要建什么，应该如何建造，如何施工。建房子是一个很复杂的过程，单凭一双手就想建房子，即便可能也非常困难。如果承包商与懂得如何建造房子的建筑商互相协调，这一过程将变得简单而且易于管理。

